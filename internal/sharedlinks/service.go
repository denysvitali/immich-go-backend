package sharedlinks

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"golang.org/x/crypto/bcrypt"

	"github.com/denysvitali/immich-go-backend/internal/db/sqlc"
)

// Service handles shared link operations
type Service struct {
	db *sqlc.Queries
}

// NewService creates a new shared links service
func NewService(db *sqlc.Queries) *Service {
	return &Service{db: db}
}

// SharedLink represents a shared link
type SharedLink struct {
	ID            uuid.UUID  `json:"id"`
	UserID        uuid.UUID  `json:"userId"`
	Key           string     `json:"key"`
	Type          string     `json:"type"`
	Description   string     `json:"description,omitempty"`
	Password      string     `json:"-"`
	ExpiresAt     *time.Time `json:"expiresAt,omitempty"`
	AllowDownload bool       `json:"allowDownload"`
	AllowUpload   bool       `json:"allowUpload"`
	ShowExif      bool       `json:"showExif"`
	AssetCount    int        `json:"assetCount"`
	AlbumID       *uuid.UUID `json:"albumId,omitempty"`
	CreatedAt     time.Time  `json:"createdAt"`
	UpdatedAt     time.Time  `json:"updatedAt"`
}

// CreateSharedLinkRequest represents a request to create a shared link
type CreateSharedLinkRequest struct {
	Type          string     `json:"type"`
	AssetIDs      []string   `json:"assetIds,omitempty"`
	AlbumID       *string    `json:"albumId,omitempty"`
	Description   string     `json:"description,omitempty"`
	Password      string     `json:"password,omitempty"`
	ExpiresAt     *time.Time `json:"expiresAt,omitempty"`
	AllowDownload bool       `json:"allowDownload"`
	AllowUpload   bool       `json:"allowUpload"`
	ShowExif      bool       `json:"showExif"`
}

// UpdateSharedLinkRequest represents a request to update a shared link
type UpdateSharedLinkRequest struct {
	Description      *string    `json:"description,omitempty"`
	Password         *string    `json:"password,omitempty"`
	ExpiresAt        *time.Time `json:"expiresAt,omitempty"`
	AllowDownload    *bool      `json:"allowDownload,omitempty"`
	AllowUpload      *bool      `json:"allowUpload,omitempty"`
	ShowExif         *bool      `json:"showExif,omitempty"`
	ChangeExpiryTime bool       `json:"changeExpiryTime,omitempty"`
}

// CreateSharedLink creates a new shared link
func (s *Service) CreateSharedLink(ctx context.Context, userID uuid.UUID, req *CreateSharedLinkRequest) (*SharedLink, error) {
	// Generate a unique key for the shared link
	key := generateKey()

	// Hash password if provided
	var hashedPassword pgtype.Text
	if req.Password != "" {
		hashed, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
		if err != nil {
			return nil, fmt.Errorf("failed to hash password: %w", err)
		}
		hashedPassword = pgtype.Text{String: string(hashed), Valid: true}
	}

	// Parse album ID if provided
	var albumID pgtype.UUID
	if req.AlbumID != nil {
		aid, err := uuid.Parse(*req.AlbumID)
		if err != nil {
			return nil, fmt.Errorf("invalid album ID: %w", err)
		}
		albumID = pgtype.UUID{Bytes: aid, Valid: true}
	}

	// Convert expires at
	var expiresAt pgtype.Timestamptz
	if req.ExpiresAt != nil {
		expiresAt = pgtype.Timestamptz{Time: *req.ExpiresAt, Valid: true}
	}

	// Create shared link in database
	// Note: ID and CreatedAt are auto-generated by the database
	params := sqlc.CreateSharedLinkParams{
		UserId:        pgtype.UUID{Bytes: userID, Valid: true},
		Key:           []byte(key),
		Type:          req.Type,
		Description:   pgtype.Text{String: req.Description, Valid: req.Description != ""},
		Password:      hashedPassword,
		ExpiresAt:     expiresAt,
		AllowDownload: req.AllowDownload,
		AllowUpload:   req.AllowUpload,
		ShowExif:      req.ShowExif,
		AlbumId:       albumID,
	}

	link, err := s.db.CreateSharedLink(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to create shared link: %w", err)
	}

	// Add assets to shared link if provided
	if len(req.AssetIDs) > 0 {
		for _, assetIDStr := range req.AssetIDs {
			assetID, err := uuid.Parse(assetIDStr)
			if err != nil {
				continue
			}

			err = s.db.AddAssetToSharedLink(ctx, sqlc.AddAssetToSharedLinkParams{
				AssetsId:      pgtype.UUID{Bytes: assetID, Valid: true},
				SharedLinksId: link.ID,
			})
			if err != nil {
				// Log error but continue
				continue
			}
		}
	}

	// Convert to response format
	return convertSharedLink(&link, len(req.AssetIDs)), nil
}

// GetSharedLink retrieves a shared link by ID
func (s *Service) GetSharedLink(ctx context.Context, userID uuid.UUID, linkID uuid.UUID) (*SharedLink, error) {
	link, err := s.db.GetSharedLink(ctx, pgtype.UUID{Bytes: linkID, Valid: true})
	if err != nil {
		return nil, fmt.Errorf("shared link not found: %w", err)
	}

	// Verify ownership
	if link.UserId.Bytes != userID {
		return nil, fmt.Errorf("access denied")
	}

	// Get asset count
	assets, err := s.db.GetSharedLinkAssets(ctx, link.ID)
	if err != nil {
		assets = []sqlc.Asset{} // Default to empty if error
	}

	return convertSharedLink(&link, len(assets)), nil
}

// GetSharedLinkByKey retrieves a shared link by its key
func (s *Service) GetSharedLinkByKey(ctx context.Context, key string, password string) (*SharedLink, error) {
	link, err := s.db.GetSharedLinkByKey(ctx, []byte(key))
	if err != nil {
		return nil, fmt.Errorf("shared link not found: %w", err)
	}

	// Check if link has expired
	if link.ExpiresAt.Valid && link.ExpiresAt.Time.Before(time.Now()) {
		return nil, fmt.Errorf("shared link has expired")
	}

	// Verify password if set
	if link.Password.Valid && link.Password.String != "" {
		if password == "" {
			return nil, fmt.Errorf("password required")
		}
		err := bcrypt.CompareHashAndPassword([]byte(link.Password.String), []byte(password))
		if err != nil {
			return nil, fmt.Errorf("invalid password")
		}
	}

	// Get asset count
	assets, err := s.db.GetSharedLinkAssets(ctx, link.ID)
	if err != nil {
		assets = []sqlc.Asset{}
	}

	return convertSharedLink(&link, len(assets)), nil
}

// GetSharedLinks retrieves all shared links for a user
func (s *Service) GetSharedLinks(ctx context.Context, userID uuid.UUID) ([]*SharedLink, error) {
	links, err := s.db.GetSharedLinks(ctx, pgtype.UUID{Bytes: userID, Valid: true})
	if err != nil {
		return nil, fmt.Errorf("failed to get shared links: %w", err)
	}

	result := make([]*SharedLink, 0, len(links))
	for _, link := range links {
		// Get asset count for each link
		assets, err := s.db.GetSharedLinkAssets(ctx, link.ID)
		if err != nil {
			assets = []sqlc.Asset{}
		}
		result = append(result, convertSharedLink(&link, len(assets)))
	}

	return result, nil
}

// UpdateSharedLink updates an existing shared link
func (s *Service) UpdateSharedLink(ctx context.Context, userID uuid.UUID, linkID uuid.UUID, req *UpdateSharedLinkRequest) (*SharedLink, error) {
	// Get existing link to verify ownership
	existing, err := s.db.GetSharedLink(ctx, pgtype.UUID{Bytes: linkID, Valid: true})
	if err != nil {
		return nil, fmt.Errorf("shared link not found: %w", err)
	}

	if existing.UserId.Bytes != userID {
		return nil, fmt.Errorf("access denied")
	}

	// Prepare update parameters
	params := sqlc.UpdateSharedLinkParams{
		ID:            pgtype.UUID{Bytes: linkID, Valid: true},
		Description:   existing.Description,
		AllowDownload: pgtype.Bool{Bool: existing.AllowDownload, Valid: true},
		AllowUpload:   pgtype.Bool{Bool: existing.AllowUpload, Valid: true},
		ShowExif:      pgtype.Bool{Bool: existing.ShowExif, Valid: true},
		Password:      existing.Password,
		ExpiresAt:     existing.ExpiresAt,
	}

	// Update fields if provided
	if req.Description != nil {
		params.Description = pgtype.Text{String: *req.Description, Valid: *req.Description != ""}
	}

	if req.AllowDownload != nil {
		params.AllowDownload = pgtype.Bool{Bool: *req.AllowDownload, Valid: true}
	}

	if req.AllowUpload != nil {
		params.AllowUpload = pgtype.Bool{Bool: *req.AllowUpload, Valid: true}
	}

	if req.ShowExif != nil {
		params.ShowExif = pgtype.Bool{Bool: *req.ShowExif, Valid: true}
	}

	if req.Password != nil {
		if *req.Password == "" {
			// Clear password
			params.Password = pgtype.Text{Valid: false}
		} else {
			// Hash new password
			hashed, err := bcrypt.GenerateFromPassword([]byte(*req.Password), bcrypt.DefaultCost)
			if err != nil {
				return nil, fmt.Errorf("failed to hash password: %w", err)
			}
			params.Password = pgtype.Text{String: string(hashed), Valid: true}
		}
	}

	if req.ChangeExpiryTime {
		if req.ExpiresAt != nil {
			params.ExpiresAt = pgtype.Timestamptz{Time: *req.ExpiresAt, Valid: true}
		} else {
			params.ExpiresAt = pgtype.Timestamptz{Valid: false}
		}
	}

	// Update the link
	updated, err := s.db.UpdateSharedLink(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to update shared link: %w", err)
	}

	// Get asset count
	assets, err := s.db.GetSharedLinkAssets(ctx, updated.ID)
	if err != nil {
		assets = []sqlc.Asset{}
	}

	return convertSharedLink(&updated, len(assets)), nil
}

// DeleteSharedLink deletes a shared link
func (s *Service) DeleteSharedLink(ctx context.Context, userID uuid.UUID, linkID uuid.UUID) error {
	// Get existing link to verify ownership
	existing, err := s.db.GetSharedLink(ctx, pgtype.UUID{Bytes: linkID, Valid: true})
	if err != nil {
		return fmt.Errorf("shared link not found: %w", err)
	}

	if existing.UserId.Bytes != userID {
		return fmt.Errorf("access denied")
	}

	// Delete the link
	err = s.db.DeleteSharedLink(ctx, pgtype.UUID{Bytes: linkID, Valid: true})
	if err != nil {
		return fmt.Errorf("failed to delete shared link: %w", err)
	}

	return nil
}

// AddAssetsToSharedLink adds assets to a shared link
func (s *Service) AddAssetsToSharedLink(ctx context.Context, userID uuid.UUID, linkID uuid.UUID, assetIDs []string) error {
	// Get existing link to verify ownership
	existing, err := s.db.GetSharedLink(ctx, pgtype.UUID{Bytes: linkID, Valid: true})
	if err != nil {
		return fmt.Errorf("shared link not found: %w", err)
	}

	if existing.UserId.Bytes != userID {
		return fmt.Errorf("access denied")
	}

	// Add each asset
	for _, assetIDStr := range assetIDs {
		assetID, err := uuid.Parse(assetIDStr)
		if err != nil {
			continue
		}

		err = s.db.AddAssetToSharedLink(ctx, sqlc.AddAssetToSharedLinkParams{
			AssetsId:      pgtype.UUID{Bytes: assetID, Valid: true},
			SharedLinksId: existing.ID,
		})
		if err != nil {
			// Log error but continue
			continue
		}
	}

	return nil
}

// RemoveAssetsFromSharedLink removes assets from a shared link
func (s *Service) RemoveAssetsFromSharedLink(ctx context.Context, userID uuid.UUID, linkID uuid.UUID, assetIDs []string) error {
	// Get existing link to verify ownership
	existing, err := s.db.GetSharedLink(ctx, pgtype.UUID{Bytes: linkID, Valid: true})
	if err != nil {
		return fmt.Errorf("shared link not found: %w", err)
	}

	if existing.UserId.Bytes != userID {
		return fmt.Errorf("access denied")
	}

	// Remove each asset
	for _, assetIDStr := range assetIDs {
		assetID, err := uuid.Parse(assetIDStr)
		if err != nil {
			continue
		}

		err = s.db.RemoveAssetFromSharedLink(ctx, sqlc.RemoveAssetFromSharedLinkParams{
			AssetsId:      pgtype.UUID{Bytes: assetID, Valid: true},
			SharedLinksId: existing.ID,
		})
		if err != nil {
			// Log error but continue
			continue
		}
	}

	return nil
}

// GetSharedLinkAssets retrieves assets from a shared link
func (s *Service) GetSharedLinkAssets(ctx context.Context, key string, password string) ([]sqlc.Asset, error) {
	// First verify access to the shared link
	link, err := s.GetSharedLinkByKey(ctx, key, password)
	if err != nil {
		return nil, err
	}

	// Get assets
	assets, err := s.db.GetSharedLinkAssets(ctx, pgtype.UUID{Bytes: link.ID, Valid: true})
	if err != nil {
		return nil, fmt.Errorf("failed to get shared link assets: %w", err)
	}

	return assets, nil
}

// Helper functions

// generateKey generates a unique key for a shared link
func generateKey() string {
	b := make([]byte, 32)
	if _, err := rand.Read(b); err != nil {
		// This should never happen with crypto/rand
		panic("failed to generate random bytes: " + err.Error())
	}
	return base64.URLEncoding.EncodeToString(b)
}

// convertSharedLink converts a database shared link to the service format
func convertSharedLink(link *sqlc.SharedLink, assetCount int) *SharedLink {
	result := &SharedLink{
		ID:            link.ID.Bytes,
		UserID:        link.UserId.Bytes,
		Key:           string(link.Key),
		Type:          link.Type,
		AllowDownload: link.AllowDownload,
		AllowUpload:   link.AllowUpload,
		ShowExif:      link.ShowExif,
		AssetCount:    assetCount,
		CreatedAt:     link.CreatedAt.Time,
		UpdatedAt:     link.CreatedAt.Time, // Using CreatedAt as UpdatedAt isn't in the model
	}

	if link.Description.Valid {
		result.Description = link.Description.String
	}

	if link.ExpiresAt.Valid {
		result.ExpiresAt = &link.ExpiresAt.Time
	}

	if link.AlbumId.Valid {
		albumUUID := uuid.UUID(link.AlbumId.Bytes)
		result.AlbumID = &albumUUID
	}

	// Don't include the actual password hash in the response
	if link.Password.Valid && link.Password.String != "" {
		result.Password = "[PROTECTED]"
	}

	return result
}
